<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Realistic Tulip Bouquet</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #8b5fbf 0%, #6a4c93 50%, #4a3570 100%);
            font-family: Arial, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            display: none;
        }
        canvas {
            display: block;
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸŒ· Realistic Tulip Bouquet ðŸŒ·</h3>
        <p>Drag to rotate â€¢ Scroll to zoom</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, bouquets = [];
        let tulips = [];
        let ribbon;
        let time = 0;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x6a4c93, 15, 50);

            // Camera - adjust for mobile if needed
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Adjust camera position based on screen size
            const isMobile = window.innerWidth < 768;
            if (isMobile) {
                camera.position.set(0, 5, 25);
            } else {
                camera.position.set(0, 5, 20);
            }
            camera.lookAt(0, 3, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xff9ed8, 0.6, 25);
            pointLight1.position.set(-6, 6, 6);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xc4a3ff, 0.5, 25);
            pointLight2.position.set(6, 4, -6);
            scene.add(pointLight2);

            // Create 3 bouquets centered - close together
            const bouquetPositions = [
                { x: -3.5, z: 0 },   // Left
                { x: 0, z: 0 },      // Center
                { x: 3.5, z: 0 }     // Right
            ];

            bouquetPositions.forEach((pos, index) => {
                const bouquet = new THREE.Group();
                createTulips(bouquet);
                createRibbon(bouquet);
                
                // Final position - centered, no animation
                bouquet.scale.set(1, 1, 1);
                bouquet.rotation.y = 0;
                bouquet.position.set(pos.x, 0, pos.z);
                bouquet.userData.index = index;
                
                bouquets.push(bouquet);
                scene.add(bouquet);
            });

            // Ground plane centered
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.4 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);

            // Mouse controls - control all bouquets together
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    bouquets.forEach(bouquet => {
                        bouquet.rotation.y += deltaX * 0.01;
                        bouquet.rotation.x += deltaY * 0.01;
                    });
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch controls for mobile
            let previousTouchPosition = { x: 0, y: 0 };
            let touchDistance = 0;

            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    previousTouchPosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                } else if (e.touches.length === 2) {
                    // Pinch zoom start
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    // Single touch - rotate
                    const deltaX = e.touches[0].clientX - previousTouchPosition.x;
                    const deltaY = e.touches[0].clientY - previousTouchPosition.y;
                    
                    bouquets.forEach(bouquet => {
                        bouquet.rotation.y += deltaX * 0.01;
                        bouquet.rotation.x += deltaY * 0.01;
                    });
                    
                    previousTouchPosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                } else if (e.touches.length === 2) {
                    // Pinch zoom
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const delta = distance - touchDistance;
                    
                    camera.position.z -= delta * 0.05;
                    camera.position.z = Math.max(8, Math.min(35, camera.position.z));
                    
                    touchDistance = distance;
                }
            });

            renderer.domElement.addEventListener('touchend', (e) => {
                e.preventDefault();
            });

            // Zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(8, Math.min(25, camera.position.z));
            });

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function createTulips(bouquet) {
            const tulipColors = [
                { base: 0xff1493, tip: 0xff69b4 },    // Deep pink to light pink
                { base: 0xff69b4, tip: 0xffb6d9 },    // Light pink to lighter
                { base: 0xdc143c, tip: 0xff6b9d },    // Crimson to pink
                { base: 0xff1493, tip: 0xffc0cb },    // Deep pink to soft pink
                { base: 0xff69b4, tip: 0xffd9e8 },    // Medium pink gradient
                { base: 0xff1493, tip: 0xff69b4 },    
                { base: 0xdc143c, tip: 0xff8fa5 },    
                { base: 0xff69b4, tip: 0xffb6d9 },    
                { base: 0xff1493, tip: 0xffc0cb },    
                { base: 0xff6b9d, tip: 0xffd9e8 }     
            ];

            const positions = [
                { x: 0, z: 0, rot: 0, height: 8.5 },
                { x: -1.3, z: 0.6, rot: 0.35, height: 8.0 },
                { x: 1.3, z: 0.6, rot: -0.35, height: 8.2 },
                { x: -0.9, z: -0.9, rot: 0.5, height: 7.5 },
                { x: 0.9, z: -0.9, rot: -0.5, height: 7.7 },
                { x: -1.9, z: 0.1, rot: 0.25, height: 7.2 },
                { x: 1.9, z: 0.1, rot: -0.25, height: 7.3 },
                { x: 0, z: 1.3, rot: 0.15, height: 7.8 },
                { x: -1.6, z: -0.6, rot: 0.4, height: 7.0 },
                { x: 1.6, z: -0.6, rot: -0.4, height: 7.4 }
            ];

            positions.forEach((pos, i) => {
                const tulip = createRealisticTulip(tulipColors[i], pos.height);
                tulip.position.set(pos.x, 0, pos.z);
                tulip.rotation.z = pos.rot;
                tulip.userData.baseY = 0;
                tulip.userData.offset = i * 0.5;
                tulips.push(tulip);
                bouquet.add(tulip);
            });
        }

        function createRealisticTulip(colorScheme, stemHeight) {
            const tulipGroup = new THREE.Group();

            // Stem - realistic green with texture
            const stemCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0.05, stemHeight * 0.3, 0.02),
                new THREE.Vector3(-0.03, stemHeight * 0.6, 0.01),
                new THREE.Vector3(0, stemHeight, 0)
            ]);

            const stemGeometry = new THREE.TubeGeometry(stemCurve, 32, 0.08, 8, false);
            const stemMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2d5016,
                shininess: 20,
                specular: 0x1a2d0f
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.castShadow = true;
            tulipGroup.add(stem);

            // Leaf - realistic tulip leaf
            const leafShape = new THREE.Shape();
            leafShape.moveTo(0, 0);
            leafShape.quadraticCurveTo(0.3, 0.5, 0.35, 1.2);
            leafShape.quadraticCurveTo(0.3, 1.8, 0.2, 2.2);
            leafShape.quadraticCurveTo(0.1, 2.4, 0, 2.5);
            leafShape.quadraticCurveTo(-0.1, 2.4, -0.2, 2.2);
            leafShape.quadraticCurveTo(-0.3, 1.8, -0.35, 1.2);
            leafShape.quadraticCurveTo(-0.3, 0.5, 0, 0);

            const leafGeometry = new THREE.ExtrudeGeometry(leafShape, {
                depth: 0.05,
                bevelEnabled: true,
                bevelThickness: 0.02,
                bevelSize: 0.02,
                bevelSegments: 3
            });

            const leafMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3a6e1f,
                side: THREE.DoubleSide,
                shininess: 40,
                specular: 0x2d5016
            });

            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.position.y = stemHeight * 0.4;
            leaf.rotation.y = Math.PI / 4;
            leaf.rotation.x = -0.5;
            leaf.castShadow = true;
            tulipGroup.add(leaf);

            // Flower head
            const flowerGroup = new THREE.Group();
            flowerGroup.position.y = stemHeight;

            // Create realistic tulip petals (6 petals - 3 outer, 3 inner)
            for (let i = 0; i < 6; i++) {
                const isOuter = i < 3;
                const petal = createRealisticPetal(colorScheme, isOuter);
                const angle = (i / 3) * Math.PI * 2 / 3;
                
                if (isOuter) {
                    petal.position.x = Math.cos(angle) * 0.45;
                    petal.position.z = Math.sin(angle) * 0.45;
                    petal.rotation.y = angle;
                    petal.rotation.x = -0.4;
                } else {
                    const innerAngle = angle + Math.PI / 3;
                    petal.position.x = Math.cos(innerAngle) * 0.3;
                    petal.position.z = Math.sin(innerAngle) * 0.3;
                    petal.rotation.y = innerAngle;
                    petal.rotation.x = -0.25;
                }
                
                flowerGroup.add(petal);
            }

            // Add "I love you" text on the front of the flower
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Create gradient background (semi-transparent)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add decorative border
            ctx.strokeStyle = '#ff69b4';
            ctx.lineWidth = 8;
            ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
            
            // Draw text
            ctx.fillStyle = '#dc143c';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('I love you', canvas.width / 2, canvas.height / 2);
            
            // Add small hearts
            ctx.font = '40px Arial';
            ctx.fillText('â™¥', canvas.width / 2 - 150, canvas.height / 2 - 60);
            ctx.fillText('â™¥', canvas.width / 2 + 150, canvas.height / 2 - 60);
            ctx.fillText('â™¥', canvas.width / 2 - 150, canvas.height / 2 + 60);
            ctx.fillText('â™¥', canvas.width / 2 + 150, canvas.height / 2 + 60);
            
            const texture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const textGeometry = new THREE.PlaneGeometry(2, 1);
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            
            // Position text in front of the flower (front side)
            textMesh.position.z = 0.8;
            textMesh.position.y = 0.5;
            
            flowerGroup.add(textMesh);

            // Realistic stamen (center of flower)
            const stamenGroup = new THREE.Group();
            
            // Pistil (center)
            const pistilGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.4, 6);
            const pistilMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4a5c2a,
                shininess: 60
            });
            const pistil = new THREE.Mesh(pistilGeometry, pistilMaterial);
            pistil.position.y = 0.2;
            pistil.castShadow = true;
            stamenGroup.add(pistil);

            // Anthers around pistil
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const antherGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const antherMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a1a00,
                    shininess: 80
                });
                const anther = new THREE.Mesh(antherGeometry, antherMaterial);
                anther.position.x = Math.cos(angle) * 0.15;
                anther.position.y = 0.15;
                anther.position.z = Math.sin(angle) * 0.15;
                anther.castShadow = true;
                stamenGroup.add(anther);
            }

            flowerGroup.add(stamenGroup);
            tulipGroup.add(flowerGroup);

            return tulipGroup;
        }

        function createRealisticPetal(colorScheme, isOuter) {
            const petalShape = new THREE.Shape();
            
            // More realistic tulip petal shape
            petalShape.moveTo(0, 0);
            petalShape.bezierCurveTo(0.4, 0.3, 0.55, 0.8, 0.6, 1.3);
            petalShape.bezierCurveTo(0.58, 1.7, 0.45, 2.0, 0.3, 2.2);
            petalShape.bezierCurveTo(0.15, 2.35, 0, 2.4, -0.15, 2.35);
            petalShape.bezierCurveTo(-0.3, 2.25, -0.45, 2.0, -0.5, 1.7);
            petalShape.bezierCurveTo(-0.55, 1.3, -0.5, 0.8, -0.4, 0.4);
            petalShape.bezierCurveTo(-0.3, 0.1, -0.1, 0, 0, 0);

            const extrudeSettings = {
                depth: 0.15,
                bevelEnabled: true,
                bevelThickness: 0.08,
                bevelSize: 0.08,
                bevelSegments: 5,
                curveSegments: 24
            };

            const petalGeometry = new THREE.ExtrudeGeometry(petalShape, extrudeSettings);

            // Gradient-like effect using vertex colors
            const colors = new Float32Array(petalGeometry.attributes.position.count * 3);
            const baseColor = new THREE.Color(colorScheme.base);
            const tipColor = new THREE.Color(colorScheme.tip);

            for (let i = 0; i < petalGeometry.attributes.position.count; i++) {
                const y = petalGeometry.attributes.position.getY(i);
                const t = Math.min(1, Math.max(0, y / 2.4));
                const color = new THREE.Color().lerpColors(baseColor, tipColor, t);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            petalGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const petalMaterial = new THREE.MeshPhongMaterial({ 
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 90,
                specular: 0x555555,
                flatShading: false
            });

            const petal = new THREE.Mesh(petalGeometry, petalMaterial);
            petal.castShadow = true;
            petal.receiveShadow = true;
            
            return petal;
        }

        function createRibbon(bouquet) {
            const ribbonGroup = new THREE.Group();
            
            // Kraft paper materials - more realistic brown paper
            const kraftPaper = new THREE.MeshLambertMaterial({ 
                color: 0xd4a373,
                flatShading: false,
                side: THREE.DoubleSide
            });

            const darkKraft = new THREE.MeshLambertMaterial({ 
                color: 0xb08968,
                flatShading: false,
                side: THREE.DoubleSide
            });

            const lightKraft = new THREE.MeshLambertMaterial({ 
                color: 0xe8c5a0,
                flatShading: false,
                side: THREE.DoubleSide
            });

            // Create realistic paper wrapping with natural folds
            const numSheets = 12;
            const materials = [kraftPaper, darkKraft, lightKraft];
            
            for (let i = 0; i < numSheets; i++) {
                const angle = (i / numSheets) * Math.PI * 2;
                
                const sheetShape = new THREE.Shape();
                sheetShape.moveTo(0, 0);
                sheetShape.lineTo(1.8, 0);
                sheetShape.quadraticCurveTo(2.2, 0.4, 2.5, 1.2);
                sheetShape.quadraticCurveTo(2.7, 2.0, 2.8, 2.8);
                sheetShape.quadraticCurveTo(2.9, 3.3, 3.1, 4.0);
                sheetShape.quadraticCurveTo(3.2, 4.3, 3.0, 4.6);
                sheetShape.quadraticCurveTo(2.6, 4.8, 2.0, 4.6);
                sheetShape.quadraticCurveTo(1.2, 4.4, 0.6, 4.0);
                sheetShape.quadraticCurveTo(0.1, 3.6, 0, 3.0);
                sheetShape.lineTo(0, 0);

                const sheetGeometry = new THREE.ShapeGeometry(sheetShape);
                const sheet = new THREE.Mesh(sheetGeometry, materials[i % 3]);
                
                const radiusOffset = 0.6 + (i % 3) * 0.12;
                sheet.position.x = Math.cos(angle) * radiusOffset;
                sheet.position.z = Math.sin(angle) * radiusOffset;
                sheet.rotation.y = -angle + Math.PI / 2;
                sheet.rotation.x = -0.15 + (Math.random() - 0.5) * 0.25;
                sheet.rotation.z = -0.08 + (Math.random() - 0.5) * 0.12;
                
                sheet.castShadow = true;
                sheet.receiveShadow = true;
                ribbonGroup.add(sheet);
            }

            // Paper texture with creases
            for (let i = 0; i < numSheets * 2; i++) {
                const angle = (i / (numSheets * 2)) * Math.PI * 2;
                const creaseShape = new THREE.Shape();
                creaseShape.moveTo(0, 0);
                creaseShape.lineTo(0.08, 0);
                creaseShape.lineTo(0.08, 3.2);
                creaseShape.lineTo(0, 3.2);
                
                const creaseGeometry = new THREE.ShapeGeometry(creaseShape);
                const creaseMaterial = new THREE.MeshLambertMaterial({
                    color: 0xa67c52,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                
                const crease = new THREE.Mesh(creaseGeometry, creaseMaterial);
                crease.position.x = Math.cos(angle) * 2.0;
                crease.position.y = 1.2;
                crease.position.z = Math.sin(angle) * 2.0;
                crease.rotation.y = -angle + Math.PI / 2;
                crease.rotation.x = -0.25;
                ribbonGroup.add(crease);
            }

            // Twine/string bow - natural fiber look
            const twineColor = 0x8b7355;
            const twineMaterial = new THREE.MeshPhongMaterial({ 
                color: twineColor,
                shininess: 15,
                specular: 0x333333
            });

            // Twine wrap bands
            for (let i = 0; i < 3; i++) {
                const twineWrapGeometry = new THREE.TorusGeometry(2.2, 0.12, 8, 32);
                const twineWrap = new THREE.Mesh(twineWrapGeometry, twineMaterial);
                twineWrap.position.y = 1.8 + i * 0.3;
                twineWrap.rotation.x = Math.PI / 2;
                twineWrap.castShadow = true;
                ribbonGroup.add(twineWrap);
            }

            // Natural twine bow
            const createTwineBowLoop = (xOffset, rotation) => {
                const loopGroup = new THREE.Group();
                
                const loopCurve = new THREE.EllipseCurve(0, 0, 0.8, 0.7, 0, Math.PI * 2, false, 0);
                const loopPoints = loopCurve.getPoints(50);
                const loopShape = new THREE.Shape(loopPoints);
                
                const loopGeometry = new THREE.ExtrudeGeometry(loopShape, {
                    depth: 0.35,
                    bevelEnabled: true,
                    bevelThickness: 0.08,
                    bevelSize: 0.05,
                    bevelSegments: 3
                });
                
                const loop = new THREE.Mesh(loopGeometry, twineMaterial);
                loop.castShadow = true;
                loopGroup.add(loop);
                
                loopGroup.position.set(xOffset, 2.2, 2.3);
                loopGroup.rotation.y = rotation;
                loopGroup.rotation.x = Math.PI / 2;
                
                return loopGroup;
            };

            ribbonGroup.add(createTwineBowLoop(-0.9, Math.PI / 6));
            ribbonGroup.add(createTwineBowLoop(0.9, -Math.PI / 6));

            // Bow knot
            const knotGeometry = new THREE.SphereGeometry(0.4, 12, 12);
            const knot = new THREE.Mesh(knotGeometry, twineMaterial);
            knot.position.set(0, 2.2, 2.4);
            knot.scale.set(1.2, 0.8, 0.7);
            knot.castShadow = true;
            ribbonGroup.add(knot);

            // Twine tails hanging down
            const createTwineTail = (xOffset, zRotation) => {
                const tailCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0.1, -0.8, 0.1),
                    new THREE.Vector3(-0.05, -1.6, 0.15),
                    new THREE.Vector3(0, -2.5, 0.1)
                ]);
                
                const tailGeometry = new THREE.TubeGeometry(tailCurve, 20, 0.1, 8, false);
                const tail = new THREE.Mesh(tailGeometry, twineMaterial);
                tail.position.set(xOffset, 2.0, 2.4);
                tail.rotation.z = zRotation;
                tail.castShadow = true;
                
                return tail;
            };

            ribbonGroup.add(createTwineTail(-0.6, -0.15));
            ribbonGroup.add(createTwineTail(0.6, 0.15));

            ribbon = ribbonGroup;
            bouquet.add(ribbonGroup);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const isMobile = window.innerWidth < 768;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // Adjust camera distance based on screen size
            if (isMobile) {
                camera.position.z = 25;
            } else {
                camera.position.z = 20;
            }
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
        animate();
    </script>
</body>
</html>